<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>回報地圖可視化</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <div class="container">
      <div class="map-container">
        <h1>GogoReport Visualization</h1>
        <h2>Report Forest 🌳</h2>
        <canvas id="mapCanvas" width="800" height="800"></canvas>
        <div id="legend"></div>
      </div>
      <div class="right-container">
        <div class="leaderboards-container">
          <div class="leaderboard-card">
            <h3>Impact Leaderboard</h3>
            <div id="influenceLeaderboard" class="leaderboard"></div>
          </div>
          <div class="leaderboard-card">
            <h3>Contribution Leaderboard</h3>
            <div id="contributionLeaderboard" class="leaderboard"></div>
          </div>
        </div>
        <a href="https://gogolook.slack.com/archives/C056VRPM8AE" target="_blank" class="report-button">
          Report to Build your Forest!
        </a>
      </div>
    </div>

    <div id="infoBox" class="info-box"></div>

    <script>
      // 解密函數
      function decryptApiKey(encryptedKey) {
        return atob(encryptedKey).split('').map(char => 
          String.fromCharCode(char.charCodeAt(0) ^ 42)
        ).join('');
      }

      // 加密後的 API Key (請使用實際加密後的值替換)
      const encryptedApiKey = "a2NQS3lTaAd8eRkYSxMbfVMYUl1rZ0Jubh5obH95Xxxzel1ET19F";

      // 解密 API Key
      const apiKey = decryptApiKey(encryptedApiKey);

      // 使用 spreadsheetId (這裡不需要加密,因為它不是敏感信息)
      const spreadsheetId = "1gCXrchthcYSjBcB6hBSg3ujOVoptPVukivNwPNk8TNQ";

      // 在文件頂部定義全局變
      let headers = [];
      let reportData = [];

      // 首先獲取表格元數據
      function getSheetMetadata() {
        const metadataUrl = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}?fields=sheets.properties&key=${apiKey}`;

        return fetch(metadataUrl)
          .then((response) => response.json())
          .then((data) => {
            const sheet = data.sheets[0]; // 假設我們使用第一個工作表
            return sheet.properties.gridProperties.rowCount;
          });
      }

      // 然後使用元數據來獲取數據
      function fetchDataAndDrawMap() {
        const range = "sheet1!A:J";
        const timestamp = new Date().getTime(); // 添加時間戳
        const url = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${range}?key=${apiKey}&_=${timestamp}`;

        fetch(url)
          .then((response) => response.json())
          .then((data) => {
            console.log("取的數據:", data);
            if (!data || !data.values || data.values.length < 2) {
              console.error("獲取的數據空或格式不正確");
              return;
            }
            headers = data.values[0];
            reportData = data.values.slice(1);
            resizeCanvas(); // 在數據加載後調整 canvas 大小
            animateGrowth();
            generateLeaderboards();
          })
          .catch((error) => console.error("獲取數據時出錯:", error));
      }

      const usedCoordinates = new Set();
      const plotPositions = {};
      const gridSize = 20;
      const canvasWidth = 800;
      const canvasHeight = 800;
      const adjacentOffset = [
        [1, 0],
        [-1, 0],
        [0, 1],
        [0, -1],
      ];

      function drawMap() {
        console.log("使用以下數據繪製地圖:", reportData);
        
        const canvas = document.getElementById("mapCanvas");
        const ctx = canvas.getContext("2d");

        // 清除 canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 繪製網格背景
        drawGrid(ctx);

        const urlCounts = {};
        const displayedUIDs = new Set();

        // 首先繪製所有地塊
        reportData.forEach((report) => {
          const URL = report[headers.indexOf("URL")] || "";
          const queryTimes = parseInt(report[headers.indexOf("Query Times")] || "0");
          const coordinates = report[headers.indexOf("Coordinates")];

          urlCounts[URL] = (urlCounts[URL] || 0) + 1;

          const [x, y] = coordinates.match(/\d+/g).map(num => parseInt(num) * gridSize);
          drawBlock(ctx, x, y, queryTimes, urlCounts[URL] > 1);
        });

        // 然後繪製邊框
        Object.entries(urlCounts).forEach(([url, count]) => {
          if (count > 1) {
            drawBorder(ctx, url);
          }
        });

        // 最後繪製文字
        const uidCoordinates = {};
        reportData.forEach((report) => {
          const UID = report[headers.indexOf("UID")] || "";
          const coordinates = report[headers.indexOf("Coordinates")];
          if (coordinates && !uidCoordinates[UID]) {
            const [x, y] = coordinates.match(/\d+/g).map(Number);
            uidCoordinates[UID] = { x, y };
            drawText(ctx, UID, x * gridSize, y * gridSize);
          }
        });

        addClickListener(canvas);
      }

      function drawBlock(ctx, x, y, queryTimes, hasMultipleReports, growthProgress = 1) {
        ctx.save();

        const color = getQueryTimesColor(queryTimes);
        const gradient = ctx.createLinearGradient(x, y, x, y + gridSize);
        
        gradient.addColorStop(0, lightenColor(color, 20));
        gradient.addColorStop(1, darkenColor(color, 10));

        ctx.fillStyle = gradient;
        
        // 使用 growthProgress 來控制方塊的大小
        const size = gridSize * growthProgress;
        const offset = (gridSize - size) / 2;
        ctx.fillRect(x + offset, y + offset, size, size);

        ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
        ctx.shadowBlur = 2;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;

        ctx.strokeStyle = darkenColor(color, 20);
        ctx.lineWidth = 1;
        ctx.strokeRect(x + offset, y + offset, size, size);

        // 移除這個條件判斷,不再繪製淡藍色邊框
        // if (hasMultipleReports) {
        //   ctx.strokeStyle = "#3498db";
        //   ctx.lineWidth = 2;
        //   ctx.strokeRect(x + offset, y + offset, size, size);
        // }

        ctx.restore();
      }

      // 輔助函數: 使顏色變亮
      function lightenColor(color, percent) {
        return pSBC(percent/100, color);
      }

      // 輔助函數: 使顏色變暗
      function darkenColor(color, percent) {
        return pSBC(-percent/100, color);
      }

      // pSBC - Shade Blend Convert - Version 4.0
      // https://github.com/PimpTrizkit/PJs/wiki/12.-Shade,-Blend-and-Convert-a-Web-Color-(pSBC.js)
      const pSBC=(p,c0,c1,l)=>{
          let r,g,b,P,f,t,h,i=parseInt,m=Math.round,a=typeof(c1)=="string";
          if(typeof(p)!="number"||p<-1||p>1||typeof(c0)!="string"||(c0[0]!='r'&&c0[0]!='#')||(c1&&!a))return null;
          if(!this.pSBCr)this.pSBCr=(d)=>{
              let n=d.length,x={};
              if(n>9){
                  [r,g,b,a]=d=d.split(","),n=d.length;
                  if(n<3||n>4)return null;
                  x.r=i(r[3]=="a"?r.slice(5):r.slice(4)),x.g=i(g),x.b=i(b),x.a=a?parseFloat(a):-1
              }else{
                  if(n==8||n==6||n<4)return null;
                  if(n<6)d="#"+d[1]+d[1]+d[2]+d[2]+d[3]+d[3]+(n>4?d[4]+d[4]:"");
                  d=i(d.slice(1),16);
                  if(n==9||n==5)x.r=d>>24&255,x.g=d>>16&255,x.b=d>>8&255,x.a=m((d&255)/0.255)/1000;
                  else x.r=d>>16,x.g=d>>8&255,x.b=d&255,x.a=-1
              }return x};
          h=c0.length>9,h=a?c1.length>9?true:c1=="c"?!h:false:h,f=this.pSBCr(c0),P=p<0,t=c1&&c1!="c"?this.pSBCr(c1):P?{r:0,g:0,b:0,a:-1}:{r:255,g:255,b:255,a:-1},p=P?p*-1:p,P=1-p;
          if(!f||!t)return null;
          if(l)r=m(P*f.r+p*t.r),g=m(P*f.g+p*t.g),b=m(P*f.b+p*t.b);
          else r=m((P*f.r**2+p*t.r**2)**0.5),g=m((P*f.g**2+p*t.g**2)**0.5),b=m((P*f.b**2+p*t.b**2)**0.5);
          a=f.a,t=t.a,f=a>=0||t>=0,a=f?a<0?t:t<0?a:a*P+t*p:0;
          if(h)return"rgb"+(f?"a(":"(")+r+","+g+","+b+(f?","+m(a*1000)/1000:"")+")";
          else return"#"+(4294967296+r*16777216+g*65536+b*256+(f?m(a*255):0)).toString(16).slice(1,f?undefined:-2)
      }

      function getRiskColor(riskLevel) {
        switch (riskLevel) {
          case "Malicious":
            return "#e74c3c";
          case "Suspicious":
            return "#f39c12";
          case "Safe":
            return "#2ecc71";
          default:
            return "#95a5a6";
        }
      }

      function drawText(ctx, text, x, y) {
        ctx.save();
        ctx.font = "12px Arial";
        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        ctx.fillText(text, x + gridSize / 2, y - 5); // 將文字繪製在方塊上方
        ctx.restore();
      }

      function addClickListener(canvas) {
        canvas.addEventListener("click", function(event) {
          const rect = canvas.getBoundingClientRect();
          const mouseX = event.clientX - rect.left;
          const mouseY = event.clientY - rect.top;

          const clickedReport = reportData.find(report => {
            const coordinates = report[headers.indexOf("Coordinates")];
            if (coordinates) {
              const [x, y] = coordinates.match(/\d+/g).map(Number);
              return mouseX >= x * gridSize && mouseX < (x + 1) * gridSize &&
                     mouseY >= y * gridSize && mouseY < (y + 1) * gridSize;
            }
            return false;
          });

          if (clickedReport) {
            console.log("點擊的報告:", clickedReport);
            showInfoBox(clickedReport, event.pageX, event.pageY);
            return true; // 表示點擊了地塊
          } else {
            console.log("在點擊位置未找到報告");
            return false; // 表示沒有點擊地塊
          }
        });
      }

      function showInfoBox(report, x, y) {
        const infoBox = document.getElementById("infoBox");
        infoBox.style.display = "none";
        setTimeout(() => {
          infoBox.style.left = `${x + 10}px`;
          infoBox.style.top = `${y + 10}px`;
          infoBox.style.display = "block";
          
          const url = report[headers.indexOf("URL")] || 'N/A';
          const displayUrl = url.length > 25 ? url.substring(0, 25) + '...' : url;
          
          const scamReason = report[headers.indexOf("Reason of Malicious / Suspicious")] || 'N/A';
          const description = report[headers.indexOf("Row Message")] || 'N/A';
          const queryTimes = report[headers.indexOf("Query Times")] || '0';

          infoBox.innerHTML = `
            <h3>Report Details</h3>
            <p><strong>Reporter:</strong> ${report[headers.indexOf("UID")] || 'N/A'}</p>
            <p><strong>URL:</strong> ${displayUrl}</p>
            <p><strong>Risk Level:</strong> <span class="risk-level ${(report[headers.indexOf("Risk Level")] || 'unknown').toLowerCase()}">${report[headers.indexOf("Risk Level")] || 'Unknown'}</span></p>
            <p><strong>Category:</strong> ${report[headers.indexOf("Categories")] || 'N/A'}</p>
            <p><strong>Scam Reason:</strong> ${scamReason}</p>
            <p><strong>Description:</strong> ${description}</p>
            <p><strong>Coordinate:</strong> ${report[headers.indexOf("Coordinates")] || 'N/A'}</p>
            <p><strong>Queried Amount:</strong> 🌲 x${queryTimes}</p>
          `;
        }, 0);
      }

      function createLegend() {
        const legend = document.getElementById("legend");
        const queryTimesLevels = [
          { name: "Nice Report (0)", color: "#D2B48C" },
          { name: "Good Impact (1-5)", color: "#8FBC8F" },
          { name: "Great Impact (6-20)", color: "#228B22" },
          { name: "Brilliant Impact (21-50)", color: "#006400" },
          { name: "Marvelous Impact (>50)", color: "#FFD700" }
        ];

        legend.innerHTML = "";
        queryTimesLevels.forEach((level) => {
          const item = document.createElement("div");
          item.className = "legend-item";
          const gradient = `linear-gradient(to bottom, ${lightenColor(level.color, 20)}, ${darkenColor(level.color, 10)})`;
          item.innerHTML = `
            <span class="color-box" style="background: ${gradient}; border: 1px solid ${darkenColor(level.color, 20)}"></span>
            <span>${level.name}</span>
          `;
          legend.appendChild(item);
        });
      }

      document.addEventListener("DOMContentLoaded", fetchDataAndDrawMap);

      createLegend();

      function drawBorder(ctx, url) {
        const positions = reportData
          .filter(report => report[headers.indexOf("URL")] === url)
          .map(report => {
            const coordinates = report[headers.indexOf("Coordinates")];
            const [x, y] = coordinates.match(/\d+/g).map(Number);
            return [x * gridSize, y * gridSize];
          });

        ctx.strokeStyle = "#3498db";
        ctx.lineWidth = 2;
        ctx.beginPath();
        positions.forEach(([x, y], index) => {
          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.closePath();
        ctx.stroke();
      }

      document.addEventListener('click', function(event) {
        const canvas = document.getElementById("mapCanvas");
        const infoBox = document.getElementById("infoBox");
        
        // 檢查點擊是否在 canvas 內
        const rect = canvas.getBoundingClientRect();
        const isClickInsideCanvas = 
          event.clientX >= rect.left && 
          event.clientX <= rect.right && 
          event.clientY >= rect.top && 
          event.clientY <= rect.bottom;

        // 如果點擊不在 canvas 內或者在 canvas 內但沒有點擊到地塊，則隱藏信息框
        if (!isClickInsideCanvas || (isClickInsideCanvas && !event.target.clickedBlock)) {
          infoBox.style.display = 'none';
        }
      });

      // 在 canvas 的點擊事件中設置一個標誌
      canvas.addEventListener('click', function(event) {
        event.target.clickedBlock = addClickListener(this);
      });

      function getQueryTimesColor(queryTimes) {
        if (queryTimes === 0) return "#D2B48C";  // 土黃色（土地）
        if (queryTimes >= 1 && queryTimes <= 5) return "#8FBC8F";  // 深海藻綠
        if (queryTimes >= 6 && queryTimes <= 20) return "#228B22"; // 森林綠
        if (queryTimes >= 21 && queryTimes <= 50) return "#006400"; // 深綠色
        if (queryTimes > 50) return "#FFD700";  // 金色
      }

      console.log("Headers:", headers);
      console.log("Query Times data:", reportData.map(report => report[headers.indexOf("Query Times")]));

      document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById("mapCanvas");
        const contributionBtn = document.getElementById('contributionBtn');
        const influenceBtn = document.getElementById('influenceBtn');

        fetchDataAndDrawMap();
        generateLeaderboards();
        createLegend();

        contributionBtn.addEventListener('click', () => {
          console.log('貢獻排行榜按鈕被點擊');
          contributionBtn.classList.add('active');
          influenceBtn.classList.remove('active');
          generateLeaderboards();
        });

        influenceBtn.addEventListener('click', () => {
          console.log('影響力排行榜按鈕點擊');
          influenceBtn.classList.add('active');
          contributionBtn.classList.remove('active');
          generateLeaderboards();
        });
      });

      function generateLeaderboards() {
        console.log('生成排行榜');
        const leaderboardData = {};
        reportData.forEach(report => {
          const uid = report[headers.indexOf("UID")];
          const queryTimes = parseInt(report[headers.indexOf("Query Times")] || "0");
          if (!leaderboardData[uid]) {
            leaderboardData[uid] = { contributions: 0, influence: 0 };
          }
          leaderboardData[uid].contributions++;
          leaderboardData[uid].influence += queryTimes;
        });

        console.log('排行榜數據：', leaderboardData);

        const influenceSortedData = Object.entries(leaderboardData).sort((a, b) => b[1].influence - a[1].influence);
        const contributionSortedData = Object.entries(leaderboardData).sort((a, b) => b[1].contributions - a[1].contributions);

        updateLeaderboard('influenceLeaderboard', influenceSortedData, 'influence');
        updateLeaderboard('contributionLeaderboard', contributionSortedData, 'contributions');
      }

      function updateLeaderboard(elementId, sortedData, type) {
        const leaderboardElement = document.getElementById(elementId);
        leaderboardElement.innerHTML = '';
        sortedData.slice(0, 10).forEach((item, index) => {
          const [uid, data] = item;
          const value = type === 'contributions' ? data.contributions : data.influence;
          const leaderboardItem = document.createElement('div');
          leaderboardItem.className = 'leaderboard-item';
          leaderboardItem.innerHTML = `
            <span>${index + 1}. ${uid}</span>
            <span>${value} ${type === 'contributions' ? '次回報' : '影響力'}</span>
          `;
          leaderboardElement.appendChild(leaderboardItem);
        });
      }

      function drawGrid(ctx) {
        const gridSize = 40; // 網格大小,可以根據需要調整
        const canvasWidth = ctx.canvas.width;
        const canvasHeight = ctx.canvas.height;

        ctx.beginPath();
        ctx.strokeStyle = "rgba(200, 200, 200, 0.2)"; // 淡灰色,透明度較低
        ctx.lineWidth = 1;

        // 繪製垂直線
        for (let x = 0; x <= canvasWidth; x += gridSize) {
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvasHeight);
        }

        // 繪製水平線
        for (let y = 0; y <= canvasHeight; y += gridSize) {
          ctx.moveTo(0, y);
          ctx.lineTo(canvasWidth, y);
        }

        ctx.stroke();
      }

      function animateGrowth() {
        const canvas = document.getElementById("mapCanvas");
        const ctx = canvas.getContext("2d");
        let growthProgress = 0;
        const animationDuration = 1000; // 1秒
        const startTime = performance.now();

        const urlCounts = {};
        const displayedUIDs = new Set();

        function animate(currentTime) {
          const elapsedTime = currentTime - startTime;
          growthProgress = Math.min(elapsedTime / animationDuration, 1);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawGrid(ctx);

          // 首先繪製所有地塊
          reportData.forEach((report) => {
            const URL = report[headers.indexOf("URL")] || "";
            const queryTimes = parseInt(report[headers.indexOf("Query Times")] || "0");
            const coordinates = report[headers.indexOf("Coordinates")];

            urlCounts[URL] = (urlCounts[URL] || 0) + 1;

            if (coordinates) {
              const [x, y] = coordinates.match(/\d+/g).map(Number);
              drawBlock(ctx, x * gridSize, y * gridSize, queryTimes, urlCounts[URL] > 1, growthProgress);
            }
          });

          // 然後繪製邊框
          Object.entries(urlCounts).forEach(([url, count]) => {
            if (count > 1) {
              drawBorder(ctx, url);
            }
          });

          // 最後繪製文字
          const uidCoordinates = {};
          reportData.forEach((report) => {
            const UID = report[headers.indexOf("UID")] || "";
            const coordinates = report[headers.indexOf("Coordinates")];
            if (coordinates && !uidCoordinates[UID]) {
              const [x, y] = coordinates.match(/\d+/g).map(Number);
              uidCoordinates[UID] = { x, y };
              drawText(ctx, UID, x * gridSize, y * gridSize);
            }
          });

          if (growthProgress < 1) {
            requestAnimationFrame(animate);
          } else {
            // 動畫結束後添加點擊事件監聽器
            addClickListener(canvas);
          }
        }

        requestAnimationFrame(animate);
      }

      function resizeCanvas() {
        const canvas = document.getElementById("mapCanvas");
        const container = canvas.parentElement;
        const containerWidth = container.clientWidth;
        
        canvas.width = Math.min(containerWidth, 800);
        canvas.height = canvas.width; // 保持正方形

        // 重新繪製地圖
        drawMap();
      }

      // 在 window 調整大小時重新調整 canvas
      window.addEventListener('resize', resizeCanvas);

      // 在初始加載和數據獲取後調用 resizeCanvas
      document.addEventListener("DOMContentLoaded", () => {
        resizeCanvas();
        fetchDataAndDrawMap();
      });
    </script>
  </body>
</html>
