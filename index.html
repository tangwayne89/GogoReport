<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å›å ±åœ°åœ–å¯è¦–åŒ–</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <div class="container">
      <div class="map-container">
        <h1>GogoReport Visualization</h1>
        <h2>Report Forest ğŸŒ³</h2>
        <canvas id="mapCanvas" width="800" height="800"></canvas>
        <div id="legend"></div>
      </div>
      <div class="right-container">
        <div class="leaderboards-container">
          <div class="leaderboard-card">
            <h3>Impact Leaderboard</h3>
            <div id="influenceLeaderboard" class="leaderboard"></div>
          </div>
          <div class="leaderboard-card">
            <h3>Contribution Leaderboard</h3>
            <div id="contributionLeaderboard" class="leaderboard"></div>
          </div>
        </div>
        <a href="https://gogolook.slack.com/archives/C056VRPM8AE" target="_blank" class="report-button">
          Report to Build your Forest!
        </a>
      </div>
    </div>

    <div id="infoBox" class="info-box"></div>

    <script>
      // è§£å¯†å‡½æ•¸
      function decryptApiKey(encryptedKey) {
        return atob(encryptedKey).split('').map(char => 
          String.fromCharCode(char.charCodeAt(0) ^ 42)
        ).join('');
      }

      // åŠ å¯†å¾Œçš„ API Key (è«‹ä½¿ç”¨å¯¦éš›åŠ å¯†å¾Œçš„å€¼æ›¿æ›)
      const encryptedApiKey = "a2NQS3lTaAd8eRkYSxMbfVMYUl1rZ0Jubh5obH95Xxxzel1ET19F";

      // è§£å¯† API Key
      const apiKey = decryptApiKey(encryptedApiKey);

      // ä½¿ç”¨ spreadsheetId (é€™è£¡ä¸éœ€è¦åŠ å¯†,å› ç‚ºå®ƒä¸æ˜¯æ•æ„Ÿä¿¡æ¯)
      const spreadsheetId = "1gCXrchthcYSjBcB6hBSg3ujOVoptPVukivNwPNk8TNQ";

      // åœ¨æ–‡ä»¶é ‚éƒ¨å®šç¾©å…¨å±€è®Š
      let headers = [];
      let reportData = [];

      // é¦–å…ˆç²å–è¡¨æ ¼å…ƒæ•¸æ“š
      function getSheetMetadata() {
        const metadataUrl = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}?fields=sheets.properties&key=${apiKey}`;

        return fetch(metadataUrl)
          .then((response) => response.json())
          .then((data) => {
            const sheet = data.sheets[0]; // å‡è¨­æˆ‘å€‘ä½¿ç”¨ç¬¬ä¸€å€‹å·¥ä½œè¡¨
            return sheet.properties.gridProperties.rowCount;
          });
      }

      // ç„¶å¾Œä½¿ç”¨å…ƒæ•¸æ“šä¾†ç²å–æ•¸æ“š
      function fetchDataAndDrawMap() {
        const range = "sheet1!A:J";
        const timestamp = new Date().getTime(); // æ·»åŠ æ™‚é–“æˆ³
        const url = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${range}?key=${apiKey}&_=${timestamp}`;

        fetch(url)
          .then((response) => response.json())
          .then((data) => {
            console.log("å–çš„æ•¸æ“š:", data);
            if (!data || !data.values || data.values.length < 2) {
              console.error("ç²å–çš„æ•¸æ“šç©ºæˆ–æ ¼å¼ä¸æ­£ç¢º");
              return;
            }
            headers = data.values[0];
            reportData = data.values.slice(1);
            resizeCanvas(); // åœ¨æ•¸æ“šåŠ è¼‰å¾Œèª¿æ•´ canvas å¤§å°
            animateGrowth();
            generateLeaderboards();
          })
          .catch((error) => console.error("ç²å–æ•¸æ“šæ™‚å‡ºéŒ¯:", error));
      }

      const usedCoordinates = new Set();
      const plotPositions = {};
      const gridSize = 20;
      const canvasWidth = 800;
      const canvasHeight = 800;
      const adjacentOffset = [
        [1, 0],
        [-1, 0],
        [0, 1],
        [0, -1],
      ];

      function drawMap() {
        console.log("ä½¿ç”¨ä»¥ä¸‹æ•¸æ“šç¹ªè£½åœ°åœ–:", reportData);
        
        const canvas = document.getElementById("mapCanvas");
        const ctx = canvas.getContext("2d");

        // æ¸…é™¤ canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ç¹ªè£½ç¶²æ ¼èƒŒæ™¯
        drawGrid(ctx);

        const urlCounts = {};
        const displayedUIDs = new Set();

        // é¦–å…ˆç¹ªè£½æ‰€æœ‰åœ°å¡Š
        reportData.forEach((report) => {
          const URL = report[headers.indexOf("URL")] || "";
          const queryTimes = parseInt(report[headers.indexOf("Query Times")] || "0");
          const coordinates = report[headers.indexOf("Coordinates")];

          urlCounts[URL] = (urlCounts[URL] || 0) + 1;

          const [x, y] = coordinates.match(/\d+/g).map(num => parseInt(num) * gridSize);
          drawBlock(ctx, x, y, queryTimes, urlCounts[URL] > 1);
        });

        // ç„¶å¾Œç¹ªè£½é‚Šæ¡†
        Object.entries(urlCounts).forEach(([url, count]) => {
          if (count > 1) {
            drawBorder(ctx, url);
          }
        });

        // æœ€å¾Œç¹ªè£½æ–‡å­—
        const uidCoordinates = {};
        reportData.forEach((report) => {
          const UID = report[headers.indexOf("UID")] || "";
          const coordinates = report[headers.indexOf("Coordinates")];
          if (coordinates && !uidCoordinates[UID]) {
            const [x, y] = coordinates.match(/\d+/g).map(Number);
            uidCoordinates[UID] = { x, y };
            drawText(ctx, UID, x * gridSize, y * gridSize);
          }
        });

        addClickListener(canvas);
      }

      function drawBlock(ctx, x, y, queryTimes, hasMultipleReports, growthProgress = 1) {
        ctx.save();

        const color = getQueryTimesColor(queryTimes);
        const gradient = ctx.createLinearGradient(x, y, x, y + gridSize);
        
        gradient.addColorStop(0, lightenColor(color, 20));
        gradient.addColorStop(1, darkenColor(color, 10));

        ctx.fillStyle = gradient;
        
        // ä½¿ç”¨ growthProgress ä¾†æ§åˆ¶æ–¹å¡Šçš„å¤§å°
        const size = gridSize * growthProgress;
        const offset = (gridSize - size) / 2;
        ctx.fillRect(x + offset, y + offset, size, size);

        ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
        ctx.shadowBlur = 2;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;

        ctx.strokeStyle = darkenColor(color, 20);
        ctx.lineWidth = 1;
        ctx.strokeRect(x + offset, y + offset, size, size);

        // ç§»é™¤é€™å€‹æ¢ä»¶åˆ¤æ–·,ä¸å†ç¹ªè£½æ·¡è—è‰²é‚Šæ¡†
        // if (hasMultipleReports) {
        //   ctx.strokeStyle = "#3498db";
        //   ctx.lineWidth = 2;
        //   ctx.strokeRect(x + offset, y + offset, size, size);
        // }

        ctx.restore();
      }

      // è¼”åŠ©å‡½æ•¸: ä½¿é¡è‰²è®Šäº®
      function lightenColor(color, percent) {
        return pSBC(percent/100, color);
      }

      // è¼”åŠ©å‡½æ•¸: ä½¿é¡è‰²è®Šæš—
      function darkenColor(color, percent) {
        return pSBC(-percent/100, color);
      }

      // pSBC - Shade Blend Convert - Version 4.0
      // https://github.com/PimpTrizkit/PJs/wiki/12.-Shade,-Blend-and-Convert-a-Web-Color-(pSBC.js)
      const pSBC=(p,c0,c1,l)=>{
          let r,g,b,P,f,t,h,i=parseInt,m=Math.round,a=typeof(c1)=="string";
          if(typeof(p)!="number"||p<-1||p>1||typeof(c0)!="string"||(c0[0]!='r'&&c0[0]!='#')||(c1&&!a))return null;
          if(!this.pSBCr)this.pSBCr=(d)=>{
              let n=d.length,x={};
              if(n>9){
                  [r,g,b,a]=d=d.split(","),n=d.length;
                  if(n<3||n>4)return null;
                  x.r=i(r[3]=="a"?r.slice(5):r.slice(4)),x.g=i(g),x.b=i(b),x.a=a?parseFloat(a):-1
              }else{
                  if(n==8||n==6||n<4)return null;
                  if(n<6)d="#"+d[1]+d[1]+d[2]+d[2]+d[3]+d[3]+(n>4?d[4]+d[4]:"");
                  d=i(d.slice(1),16);
                  if(n==9||n==5)x.r=d>>24&255,x.g=d>>16&255,x.b=d>>8&255,x.a=m((d&255)/0.255)/1000;
                  else x.r=d>>16,x.g=d>>8&255,x.b=d&255,x.a=-1
              }return x};
          h=c0.length>9,h=a?c1.length>9?true:c1=="c"?!h:false:h,f=this.pSBCr(c0),P=p<0,t=c1&&c1!="c"?this.pSBCr(c1):P?{r:0,g:0,b:0,a:-1}:{r:255,g:255,b:255,a:-1},p=P?p*-1:p,P=1-p;
          if(!f||!t)return null;
          if(l)r=m(P*f.r+p*t.r),g=m(P*f.g+p*t.g),b=m(P*f.b+p*t.b);
          else r=m((P*f.r**2+p*t.r**2)**0.5),g=m((P*f.g**2+p*t.g**2)**0.5),b=m((P*f.b**2+p*t.b**2)**0.5);
          a=f.a,t=t.a,f=a>=0||t>=0,a=f?a<0?t:t<0?a:a*P+t*p:0;
          if(h)return"rgb"+(f?"a(":"(")+r+","+g+","+b+(f?","+m(a*1000)/1000:"")+")";
          else return"#"+(4294967296+r*16777216+g*65536+b*256+(f?m(a*255):0)).toString(16).slice(1,f?undefined:-2)
      }

      function getRiskColor(riskLevel) {
        switch (riskLevel) {
          case "Malicious":
            return "#e74c3c";
          case "Suspicious":
            return "#f39c12";
          case "Safe":
            return "#2ecc71";
          default:
            return "#95a5a6";
        }
      }

      function drawText(ctx, text, x, y) {
        ctx.save();
        ctx.font = "12px Arial";
        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        ctx.fillText(text, x + gridSize / 2, y - 5); // å°‡æ–‡å­—ç¹ªè£½åœ¨æ–¹å¡Šä¸Šæ–¹
        ctx.restore();
      }

      function addClickListener(canvas) {
        canvas.addEventListener("click", function(event) {
          const rect = canvas.getBoundingClientRect();
          const mouseX = event.clientX - rect.left;
          const mouseY = event.clientY - rect.top;

          const clickedReport = reportData.find(report => {
            const coordinates = report[headers.indexOf("Coordinates")];
            if (coordinates) {
              const [x, y] = coordinates.match(/\d+/g).map(Number);
              return mouseX >= x * gridSize && mouseX < (x + 1) * gridSize &&
                     mouseY >= y * gridSize && mouseY < (y + 1) * gridSize;
            }
            return false;
          });

          if (clickedReport) {
            console.log("é»æ“Šçš„å ±å‘Š:", clickedReport);
            showInfoBox(clickedReport, event.pageX, event.pageY);
            return true; // è¡¨ç¤ºé»æ“Šäº†åœ°å¡Š
          } else {
            console.log("åœ¨é»æ“Šä½ç½®æœªæ‰¾åˆ°å ±å‘Š");
            return false; // è¡¨ç¤ºæ²’æœ‰é»æ“Šåœ°å¡Š
          }
        });
      }

      function showInfoBox(report, x, y) {
        const infoBox = document.getElementById("infoBox");
        infoBox.style.display = "none";
        setTimeout(() => {
          infoBox.style.left = `${x + 10}px`;
          infoBox.style.top = `${y + 10}px`;
          infoBox.style.display = "block";
          
          const url = report[headers.indexOf("URL")] || 'N/A';
          const displayUrl = url.length > 25 ? url.substring(0, 25) + '...' : url;
          
          const scamReason = report[headers.indexOf("Reason of Malicious / Suspicious")] || 'N/A';
          const description = report[headers.indexOf("Row Message")] || 'N/A';
          const queryTimes = report[headers.indexOf("Query Times")] || '0';

          infoBox.innerHTML = `
            <h3>Report Details</h3>
            <p><strong>Reporter:</strong> ${report[headers.indexOf("UID")] || 'N/A'}</p>
            <p><strong>URL:</strong> ${displayUrl}</p>
            <p><strong>Risk Level:</strong> <span class="risk-level ${(report[headers.indexOf("Risk Level")] || 'unknown').toLowerCase()}">${report[headers.indexOf("Risk Level")] || 'Unknown'}</span></p>
            <p><strong>Category:</strong> ${report[headers.indexOf("Categories")] || 'N/A'}</p>
            <p><strong>Scam Reason:</strong> ${scamReason}</p>
            <p><strong>Description:</strong> ${description}</p>
            <p><strong>Coordinate:</strong> ${report[headers.indexOf("Coordinates")] || 'N/A'}</p>
            <p><strong>Queried Amount:</strong> ğŸŒ² x${queryTimes}</p>
          `;
        }, 0);
      }

      function createLegend() {
        const legend = document.getElementById("legend");
        const queryTimesLevels = [
          { name: "Nice Report (0)", color: "#D2B48C" },
          { name: "Good Impact (1-5)", color: "#8FBC8F" },
          { name: "Great Impact (6-20)", color: "#228B22" },
          { name: "Brilliant Impact (21-50)", color: "#006400" },
          { name: "Marvelous Impact (>50)", color: "#FFD700" }
        ];

        legend.innerHTML = "";
        queryTimesLevels.forEach((level) => {
          const item = document.createElement("div");
          item.className = "legend-item";
          const gradient = `linear-gradient(to bottom, ${lightenColor(level.color, 20)}, ${darkenColor(level.color, 10)})`;
          item.innerHTML = `
            <span class="color-box" style="background: ${gradient}; border: 1px solid ${darkenColor(level.color, 20)}"></span>
            <span>${level.name}</span>
          `;
          legend.appendChild(item);
        });
      }

      document.addEventListener("DOMContentLoaded", fetchDataAndDrawMap);

      createLegend();

      function drawBorder(ctx, url) {
        const positions = reportData
          .filter(report => report[headers.indexOf("URL")] === url)
          .map(report => {
            const coordinates = report[headers.indexOf("Coordinates")];
            const [x, y] = coordinates.match(/\d+/g).map(Number);
            return [x * gridSize, y * gridSize];
          });

        ctx.strokeStyle = "#3498db";
        ctx.lineWidth = 2;
        ctx.beginPath();
        positions.forEach(([x, y], index) => {
          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.closePath();
        ctx.stroke();
      }

      document.addEventListener('click', function(event) {
        const canvas = document.getElementById("mapCanvas");
        const infoBox = document.getElementById("infoBox");
        
        // æª¢æŸ¥é»æ“Šæ˜¯å¦åœ¨ canvas å…§
        const rect = canvas.getBoundingClientRect();
        const isClickInsideCanvas = 
          event.clientX >= rect.left && 
          event.clientX <= rect.right && 
          event.clientY >= rect.top && 
          event.clientY <= rect.bottom;

        // å¦‚æœé»æ“Šä¸åœ¨ canvas å…§æˆ–è€…åœ¨ canvas å…§ä½†æ²’æœ‰é»æ“Šåˆ°åœ°å¡Šï¼Œå‰‡éš±è—ä¿¡æ¯æ¡†
        if (!isClickInsideCanvas || (isClickInsideCanvas && !event.target.clickedBlock)) {
          infoBox.style.display = 'none';
        }
      });

      // åœ¨ canvas çš„é»æ“Šäº‹ä»¶ä¸­è¨­ç½®ä¸€å€‹æ¨™èªŒ
      canvas.addEventListener('click', function(event) {
        event.target.clickedBlock = addClickListener(this);
      });

      function getQueryTimesColor(queryTimes) {
        if (queryTimes === 0) return "#D2B48C";  // åœŸé»ƒè‰²ï¼ˆåœŸåœ°ï¼‰
        if (queryTimes >= 1 && queryTimes <= 5) return "#8FBC8F";  // æ·±æµ·è—»ç¶ 
        if (queryTimes >= 6 && queryTimes <= 20) return "#228B22"; // æ£®æ—ç¶ 
        if (queryTimes >= 21 && queryTimes <= 50) return "#006400"; // æ·±ç¶ è‰²
        if (queryTimes > 50) return "#FFD700";  // é‡‘è‰²
      }

      console.log("Headers:", headers);
      console.log("Query Times data:", reportData.map(report => report[headers.indexOf("Query Times")]));

      document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById("mapCanvas");
        const contributionBtn = document.getElementById('contributionBtn');
        const influenceBtn = document.getElementById('influenceBtn');

        fetchDataAndDrawMap();
        generateLeaderboards();
        createLegend();

        contributionBtn.addEventListener('click', () => {
          console.log('è²¢ç»æ’è¡Œæ¦œæŒ‰éˆ•è¢«é»æ“Š');
          contributionBtn.classList.add('active');
          influenceBtn.classList.remove('active');
          generateLeaderboards();
        });

        influenceBtn.addEventListener('click', () => {
          console.log('å½±éŸ¿åŠ›æ’è¡Œæ¦œæŒ‰éˆ•é»æ“Š');
          influenceBtn.classList.add('active');
          contributionBtn.classList.remove('active');
          generateLeaderboards();
        });
      });

      function generateLeaderboards() {
        console.log('ç”Ÿæˆæ’è¡Œæ¦œ');
        const leaderboardData = {};
        reportData.forEach(report => {
          const uid = report[headers.indexOf("UID")];
          const queryTimes = parseInt(report[headers.indexOf("Query Times")] || "0");
          if (!leaderboardData[uid]) {
            leaderboardData[uid] = { contributions: 0, influence: 0 };
          }
          leaderboardData[uid].contributions++;
          leaderboardData[uid].influence += queryTimes;
        });

        console.log('æ’è¡Œæ¦œæ•¸æ“šï¼š', leaderboardData);

        const influenceSortedData = Object.entries(leaderboardData).sort((a, b) => b[1].influence - a[1].influence);
        const contributionSortedData = Object.entries(leaderboardData).sort((a, b) => b[1].contributions - a[1].contributions);

        updateLeaderboard('influenceLeaderboard', influenceSortedData, 'influence');
        updateLeaderboard('contributionLeaderboard', contributionSortedData, 'contributions');
      }

      function updateLeaderboard(elementId, sortedData, type) {
        const leaderboardElement = document.getElementById(elementId);
        leaderboardElement.innerHTML = '';
        sortedData.slice(0, 10).forEach((item, index) => {
          const [uid, data] = item;
          const value = type === 'contributions' ? data.contributions : data.influence;
          const leaderboardItem = document.createElement('div');
          leaderboardItem.className = 'leaderboard-item';
          leaderboardItem.innerHTML = `
            <span>${index + 1}. ${uid}</span>
            <span>${value} ${type === 'contributions' ? 'æ¬¡å›å ±' : 'å½±éŸ¿åŠ›'}</span>
          `;
          leaderboardElement.appendChild(leaderboardItem);
        });
      }

      function drawGrid(ctx) {
        const gridSize = 40; // ç¶²æ ¼å¤§å°,å¯ä»¥æ ¹æ“šéœ€è¦èª¿æ•´
        const canvasWidth = ctx.canvas.width;
        const canvasHeight = ctx.canvas.height;

        ctx.beginPath();
        ctx.strokeStyle = "rgba(200, 200, 200, 0.2)"; // æ·¡ç°è‰²,é€æ˜åº¦è¼ƒä½
        ctx.lineWidth = 1;

        // ç¹ªè£½å‚ç›´ç·š
        for (let x = 0; x <= canvasWidth; x += gridSize) {
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvasHeight);
        }

        // ç¹ªè£½æ°´å¹³ç·š
        for (let y = 0; y <= canvasHeight; y += gridSize) {
          ctx.moveTo(0, y);
          ctx.lineTo(canvasWidth, y);
        }

        ctx.stroke();
      }

      function animateGrowth() {
        const canvas = document.getElementById("mapCanvas");
        const ctx = canvas.getContext("2d");
        let growthProgress = 0;
        const animationDuration = 1000; // 1ç§’
        const startTime = performance.now();

        const urlCounts = {};
        const displayedUIDs = new Set();

        function animate(currentTime) {
          const elapsedTime = currentTime - startTime;
          growthProgress = Math.min(elapsedTime / animationDuration, 1);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawGrid(ctx);

          // é¦–å…ˆç¹ªè£½æ‰€æœ‰åœ°å¡Š
          reportData.forEach((report) => {
            const URL = report[headers.indexOf("URL")] || "";
            const queryTimes = parseInt(report[headers.indexOf("Query Times")] || "0");
            const coordinates = report[headers.indexOf("Coordinates")];

            urlCounts[URL] = (urlCounts[URL] || 0) + 1;

            if (coordinates) {
              const [x, y] = coordinates.match(/\d+/g).map(Number);
              drawBlock(ctx, x * gridSize, y * gridSize, queryTimes, urlCounts[URL] > 1, growthProgress);
            }
          });

          // ç„¶å¾Œç¹ªè£½é‚Šæ¡†
          Object.entries(urlCounts).forEach(([url, count]) => {
            if (count > 1) {
              drawBorder(ctx, url);
            }
          });

          // æœ€å¾Œç¹ªè£½æ–‡å­—
          const uidCoordinates = {};
          reportData.forEach((report) => {
            const UID = report[headers.indexOf("UID")] || "";
            const coordinates = report[headers.indexOf("Coordinates")];
            if (coordinates && !uidCoordinates[UID]) {
              const [x, y] = coordinates.match(/\d+/g).map(Number);
              uidCoordinates[UID] = { x, y };
              drawText(ctx, UID, x * gridSize, y * gridSize);
            }
          });

          if (growthProgress < 1) {
            requestAnimationFrame(animate);
          } else {
            // å‹•ç•«çµæŸå¾Œæ·»åŠ é»æ“Šäº‹ä»¶ç›£è½å™¨
            addClickListener(canvas);
          }
        }

        requestAnimationFrame(animate);
      }

      function resizeCanvas() {
        const canvas = document.getElementById("mapCanvas");
        const container = canvas.parentElement;
        const containerWidth = container.clientWidth;
        
        canvas.width = Math.min(containerWidth, 800);
        canvas.height = canvas.width; // ä¿æŒæ­£æ–¹å½¢

        // é‡æ–°ç¹ªè£½åœ°åœ–
        drawMap();
      }

      // åœ¨ window èª¿æ•´å¤§å°æ™‚é‡æ–°èª¿æ•´ canvas
      window.addEventListener('resize', resizeCanvas);

      // åœ¨åˆå§‹åŠ è¼‰å’Œæ•¸æ“šç²å–å¾Œèª¿ç”¨ resizeCanvas
      document.addEventListener("DOMContentLoaded", () => {
        resizeCanvas();
        fetchDataAndDrawMap();
      });
    </script>
  </body>
</html>
